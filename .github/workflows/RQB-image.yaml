name: Rasqberry Pi Image Release

permissions:
  contents: write
  checks: write
  id-token: write
  packages: write

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (required for main branch)'
        required: false
        type: string
      refresh_cache:
        description: 'Force cache refresh (dev branches only)'
        required: false
        type: boolean
        default: false
  push:
    branches:
      - dev*

env:
  CACHE_VERSION: v1

jobs:
  rasqberry-push-version-number:
    name: "Rasqberry: Push version number"
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.current-version.outputs.version }}
      version_num: ${{ steps.update-version.outputs.version_num }}
    steps:
      - name: "Rasqberry: Clone Repository"
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: Create Date
        id: create-date
        shell: bash
        run: |
          NOW="$(date +"%Y-%m-%d-%H%M%S")"
          echo "date=${NOW}" >> $GITHUB_OUTPUT

      - name: "Rasqberry: Get current version"
        id: current-version
        shell: bash
        run: |
          version=$(cat ./VERSION)
          echo "version=${version}" >> $GITHUB_OUTPUT

      - name: "Rasqberry: Add version file"
        id: update-version
        if: ${{ steps.current-version.outputs.version != github.event.inputs.version }}
        shell: bash
        env:
          VERSION_INPUT: ${{ github.event.inputs.version }}
          CREATE_DATE: ${{ steps.create-date.outputs.date }}
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          if [ "$BRANCH_NAME" = "main" ]; then
            if [ -z "$VERSION_INPUT" ]; then
              echo "Error: On 'main' branch you must supply a semantic version via workflow inputs." >&2
              exit 1
            fi
            VERSION_NUMBER="$VERSION_INPUT"
          else
            if [ -n "$VERSION_INPUT" ]; then
              VERSION_NUMBER="$VERSION_INPUT"
            else
              VERSION_NUMBER="${BRANCH_NAME}-${CREATE_DATE}"
            fi
          fi
          echo "version_num=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          echo "$VERSION_NUMBER" > ./VERSION

      - name: "Validate semantic version"
        if: github.ref == 'refs/heads/main'
        shell: bash
        run: |
          echo "$VERSION_INPUT" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$' \
            || { echo "â›” Invalid semantic version: $VERSION_INPUT" >&2; exit 1; }
        
      - name: "Rasqberry: git add & commit & push"
        uses: EndBug/add-and-commit@v9
        with:
          add: "./VERSION"
          default_author: github_actions
          message: "Bump version to ${{ steps.update-version.outputs.version_num }}"
          github_token: ${{ secrets.GITHUB_TOKEN }}
          tag: ${{ github.ref == 'refs/heads/main' && format('v{0} --force', steps.update-version.outputs.version_num) || format('{0} --force', steps.update-version.outputs.version_num) }}
          push: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.5.0
        with:
          cosign-release: 'v2.2.4'

  release:
    name: Create Release
    needs: rasqberry-push-version-number
    runs-on: ubuntu-latest
    outputs:
      id: ${{ steps.create-release.outputs.id }}
      upload_url: ${{ steps.create-release.outputs.upload_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest tag
        id: latest_tag
        shell: bash
        run: |
          echo "TAG_NAME=$(git describe --tags $(git rev-list --tags --max-count=1))" >> $GITHUB_OUTPUT

      - name: Generate a changelog
        uses: orhun/git-cliff-action@v1
        id: changelog
        with:
          config: ./cliff-release.toml
          args: ${{ steps.latest_tag.outputs.TAG_NAME }}..HEAD

      - name: Create Release
        id: create-release
        uses: softprops/action-gh-release@v2.2.1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          name: ${{ github.ref == 'refs/heads/main' && format('rasqberry-v{0}', needs.rasqberry-push-version-number.outputs.version_num) || format('rasqberry-{0}', needs.rasqberry-push-version-number.outputs.version_num) }}
          tag_name: ${{ github.ref == 'refs/heads/main' && format('v{0}', needs.rasqberry-push-version-number.outputs.version_num) || needs.rasqberry-push-version-number.outputs.version_num }}
          body: ${{ steps.changelog.outputs.content }}
          make_latest: true

  build:
    name: Build Image
    needs: [release]
    runs-on: ubuntu-latest
    outputs:
      asset_path: ${{ steps.set-asset.outputs.asset_path }}
      asset_name: ${{ steps.set-asset.outputs.asset_name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine if caching should be used
        id: cache-decision
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          FORCE_REFRESH="${{ github.event.inputs.refresh_cache }}"
          
          if [[ "$BRANCH_NAME" == dev* ]]; then
            if [ "$FORCE_REFRESH" == "true" ]; then
              echo "use_cache=false" >> $GITHUB_OUTPUT
              echo "Cache refresh forced by workflow input"
            else
              echo "use_cache=true" >> $GITHUB_OUTPUT
              echo "Cache enabled for development branch: $BRANCH_NAME"
            fi
          else
            echo "use_cache=false" >> $GITHUB_OUTPUT
            echo "Cache disabled for branch: $BRANCH_NAME"
          fi

      - name: Generate cache date
        id: cache-date
        if: steps.cache-decision.outputs.use_cache == 'true'
        run: |
          # Use year-month for cache key to refresh monthly
          CACHE_DATE=$(date +"%Y-%m")
          echo "cache_date=${CACHE_DATE}" >> $GITHUB_OUTPUT

      - name: Cache stage4 work directory (dev branches only)
        id: cache-stage4
        if: steps.cache-decision.outputs.use_cache == 'true'
        uses: actions/cache@v3
        with:
          path: stage4-base.tar.gz
          key: stage4-${{ env.CACHE_VERSION }}-${{ steps.cache-date.outputs.cache_date }}-bookworm-arm64-lz4

      - name: Install pi-gen dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            coreutils \
            quilt \
            parted \
            qemu-user-static \
            debootstrap \
            zerofree \
            zip \
            dosfstools \
            libarchive-tools \
            libcap2-bin \
            grep \
            rsync \
            xz-utils \
            file \
            git \
            curl \
            bc \
            gpg \
            pigz \
            lz4 \
            arch-test

      - name: Clone pi-gen
        run: |
          git clone --depth 1 --branch arm64 https://github.com/RPi-Distro/pi-gen
          cd pi-gen

      - name: Copy custom stage
        run: cp -r stage-RQB2 pi-gen/

      - name: Configure build
        run: |
          cd pi-gen
          cat > config <<EOF
          IMG_NAME=rasqberry
          RELEASE=bookworm
          DEPLOY_COMPRESSION=xz
          COMPRESSION_LEVEL=8
          LOCALE_DEFAULT=en_GB.UTF-8
          TARGET_HOSTNAME=rasqberry
          KEYBOARD_KEYMAP=gb
          KEYBOARD_LAYOUT="English (UK)"
          TIMEZONE_DEFAULT=Europe/London
          FIRST_USER_NAME=rasqberry
          FIRST_USER_PASS="Qiskit1!"
          ENABLE_SSH=1
          DISABLE_FIRST_BOOT_USER_RENAME=1
          PUBKEY_ONLY_SSH=0
          WPA_COUNTRY=GB
          EOF

      - name: Build base stages (if not cached or cache disabled)
        if: steps.cache-decision.outputs.use_cache == 'false' || steps.cache-stage4.outputs.cache-hit != 'true'
        run: |
          cd pi-gen
          echo "Building base stages 0-4..."
          echo 'STAGE_LIST="stage0 stage1 stage2 stage3 stage4"' >> config
          
          # Skip Export for stages 0-4
          touch ./stage0/SKIP_IMAGES ./stage1/SKIP_IMAGES ./stage2/SKIP_IMAGES ./stage3/SKIP_IMAGES ./stage4/SKIP_IMAGES
          
          # Skip stage5 (not needed)
          touch ./stage5/SKIP
          
          # Run build
          sudo ./build.sh
          
          # Save the work directory state for cache
          if [ "${{ steps.cache-decision.outputs.use_cache }}" == "true" ]; then
            echo "Saving work directory for cache..."
            # First, ensure stage4 rootfs exists and copy it for the next stage
            if [ -d "work/*/stage4/rootfs" ]; then
              sudo mkdir -p work/.cache-stage4
              sudo cp -al work/*/stage4/rootfs work/.cache-stage4/
            fi

            sudo tar -cf - \
              --exclude='work/*/stage*/rootfs/var/cache/apt/archives/*.deb' \
              --exclude='work/*/stage*/rootfs/tmp/*' \
              --exclude='work/*/stage*/rootfs/var/log/*' \
              --exclude='work/*/stage*/rootfs/var/cache/apt/*.bin' \
              --exclude='work/*/stage*/rootfs/var/lib/apt/lists/*' \
              --exclude='work/*/stage*/rootfs/home/*/.cache/*' \
              --exclude='work/*/stage*/rootfs/**/__pycache__' \
              --exclude='work/*/stage*/rootfs/**/*.pyc' \
              --exclude='work/*/stage*/rootfs/**/*.pyo' \
              --exclude='work/*/stage*/rootfs/usr/src/*' \
              --exclude='work/*/stage*/rootfs/var/cache/debconf/*' \
              --exclude='work/*/stage*/rootfs/boot/*.old' \
              --exclude='work/*/stage*/rootfs/var/cache/pip/*' \
              work | lz4 -1 > ../stage4-base.tar.lz4
          fi
          
          # Clean up to prepare for custom stage
          sudo rm -rf work/*/stage-RQB2 || true

      - name: Restore cached build
        if: steps.cache-stage4.outputs.cache-hit == 'true'  # Fixed: was steps.cache-restore
        run: |
          cd pi-gen
          echo "Restoring cached build..."
          lz4 -dc ../stage4-base.tar.lz4 | sudo tar -xf -
          
          # After extracting cache, restore the rootfs if it was saved
          if [ -d "work/.cache-stage4/rootfs" ]; then
            # Find the work directory with timestamp
            WORK_DIR=$(ls -d work/????-??-??-* 2>/dev/null | head -1)
            if [ -n "$WORK_DIR" ]; then
              echo "Restoring stage4 rootfs to $WORK_DIR/stage4/"
              sudo mkdir -p "$WORK_DIR/stage4/"
              sudo mv work/.cache-stage4/rootfs "$WORK_DIR/stage4/"
            fi
          fi

      - name: Build custom stage
        run: |
          cd pi-gen
          
          # Check if we should use cache and if cache was hit
          if [ "${{ steps.cache-decision.outputs.use_cache }}" == "true" ] && [ "${{ steps.cache-stage4.outputs.cache-hit }}" == "true" ]; then
            echo "Using cached base stages..."
            echo "CONTINUE=1" >> config
            echo 'STAGE_LIST="./stage-RQB2"' >> config
          else
            echo "Continuing from fresh base build..."
            echo "CONTINUE=1" >> config
            echo 'STAGE_LIST="./stage-RQB2"' >> config
          fi
          
          # Build custom stage
          sudo ./build.sh

      - name: Set dynamic asset path and name
        id: set-asset
        run: |
          cd pi-gen
          mkdir -p ../deploy
          
          # Find the final image
          FINAL_IMAGE=$(find deploy -name "*.img.xz" -type f | head -n 1)
          
          if [ -z "$FINAL_IMAGE" ]; then
            echo "Error: No image found in deploy directory"
            exit 1
          fi
          
          # Copy to deploy folder
          cp "$FINAL_IMAGE" ../deploy/
          
          # Set outputs
          FILE_NAME=$(basename "$FINAL_IMAGE")
          echo "asset_path=deploy/$FILE_NAME" >> $GITHUB_OUTPUT
          echo "asset_name=$FILE_NAME" >> $GITHUB_OUTPUT
          
          # Show file info
          echo "Built image: $FILE_NAME"
          echo "Size: $(du -h ../deploy/$FILE_NAME | cut -f1)"
          
          # Log cache usage
          if [ "${{ steps.cache-decision.outputs.use_cache }}" == "true" ]; then
            echo "Build completed with caching enabled"
            if [ "${{ steps.cache-stage4.outputs.cache-hit }}" == "true" ]; then
              echo "Cache was used - only custom stage was rebuilt"
            else
              echo "Cache miss - full build was performed"
            fi
          else
            echo "Build completed without caching (production build)"
          fi

      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.release.outputs.upload_url }}
          asset_path: ${{ steps.set-asset.outputs.asset_path }}
          asset_name: ${{ steps.set-asset.outputs.asset_name }}
          asset_content_type: application/x-xz