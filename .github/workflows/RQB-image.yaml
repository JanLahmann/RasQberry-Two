name: Rasqberry Pi Image Release

permissions:
  contents: write
  checks: write
  id-token: write
  packages: write

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (required for main branch)'
        required: false
        type: string
      refresh_cache:
        description: 'Force cache refresh (dev branches only)'
        required: false
        type: boolean
        default: false
  push:
    branches:
      - dev*

env:
  CACHE_VERSION: v1

jobs:
  rasqberry-push-version-number:
    name: "Rasqberry: Push version number"
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.current-version.outputs.version }}
      version_num: ${{ steps.update-version.outputs.version_num }}
    steps:
      - name: "Rasqberry: Clone Repository"
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: Create Date
        id: create-date
        shell: bash
        run: |
          NOW="$(date +"%Y-%m-%d-%H%M%S")"
          echo "date=${NOW}" >> $GITHUB_OUTPUT

      - name: "Rasqberry: Get current version"
        id: current-version
        shell: bash
        run: |
          version=$(cat ./VERSION)
          echo "version=${version}" >> $GITHUB_OUTPUT

      - name: "Rasqberry: Add version file"
        id: update-version
        if: ${{ steps.current-version.outputs.version != github.event.inputs.version }}
        shell: bash
        env:
          VERSION_INPUT: ${{ github.event.inputs.version }}
          CREATE_DATE: ${{ steps.create-date.outputs.date }}
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          if [ "$BRANCH_NAME" = "main" ]; then
            if [ -z "$VERSION_INPUT" ]; then
              echo "Error: On 'main' branch you must supply a semantic version via workflow inputs." >&2
              exit 1
            fi
            VERSION_NUMBER="$VERSION_INPUT"
          else
            if [ -n "$VERSION_INPUT" ]; then
              VERSION_NUMBER="$VERSION_INPUT"
            else
              VERSION_NUMBER="${BRANCH_NAME}-${CREATE_DATE}"
            fi
          fi
          echo "version_num=$VERSION_NUMBER" >> $GITHUB_OUTPUT
          echo "$VERSION_NUMBER" > ./VERSION

      - name: "Validate semantic version"
        if: github.ref == 'refs/heads/main'
        shell: bash
        run: |
          echo "$VERSION_INPUT" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$' \
            || { echo "â›” Invalid semantic version: $VERSION_INPUT" >&2; exit 1; }
        
      - name: "Rasqberry: git add & commit & push"
        uses: EndBug/add-and-commit@v9
        with:
          add: "./VERSION"
          default_author: github_actions
          message: "Bump version to ${{ steps.update-version.outputs.version_num }}"
          github_token: ${{ secrets.GITHUB_TOKEN }}
          tag: ${{ github.ref == 'refs/heads/main' && format('v{0} --force', steps.update-version.outputs.version_num) || format('{0} --force', steps.update-version.outputs.version_num) }}
          push: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.5.0
        with:
          cosign-release: 'v2.2.4'

  release:
    name: Create Release
    needs: rasqberry-push-version-number
    runs-on: ubuntu-latest
    outputs:
      id: ${{ steps.create-release.outputs.id }}
      upload_url: ${{ steps.create-release.outputs.upload_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest tag
        id: latest_tag
        shell: bash
        run: |
          echo "TAG_NAME=$(git describe --tags $(git rev-list --tags --max-count=1))" >> $GITHUB_OUTPUT

      - name: Generate a changelog
        uses: orhun/git-cliff-action@v1
        id: changelog
        with:
          config: ./cliff-release.toml
          args: ${{ steps.latest_tag.outputs.TAG_NAME }}..HEAD

      - name: Create Release
        id: create-release
        uses: softprops/action-gh-release@v2.2.1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          name: ${{ github.ref == 'refs/heads/main' && format('rasqberry-v{0}', needs.rasqberry-push-version-number.outputs.version_num) || format('rasqberry-{0}', needs.rasqberry-push-version-number.outputs.version_num) }}
          tag_name: ${{ github.ref == 'refs/heads/main' && format('v{0}', needs.rasqberry-push-version-number.outputs.version_num) || needs.rasqberry-push-version-number.outputs.version_num }}
          body: ${{ steps.changelog.outputs.content }}
          make_latest: true

  build:
    name: Build Image
    needs: [release]
    runs-on: ubuntu-latest
    outputs:
      asset_path: ${{ steps.set-asset.outputs.asset_path }}
      asset_name: ${{ steps.set-asset.outputs.asset_name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: List available caches
        run: |
          echo "Current branch: ${GITHUB_REF#refs/heads/}"
          echo "Cache key pattern: stage4-${{ env.CACHE_VERSION }}-$(date +"%Y-%m")-bookworm-arm64"
          # This won't list caches directly, but will show what key we're looking for

      - name: Determine if caching should be used
        id: cache-decision
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          FORCE_REFRESH="${{ github.event.inputs.refresh_cache }}"
          
          if [[ "$BRANCH_NAME" == dev* ]]; then
            if [ "$FORCE_REFRESH" == "true" ]; then
              echo "use_cache=false" >> $GITHUB_OUTPUT
              echo "Cache refresh forced by workflow input"
            else
              echo "use_cache=true" >> $GITHUB_OUTPUT
              echo "Cache enabled for development branch: $BRANCH_NAME"
            fi
          else
            echo "use_cache=false" >> $GITHUB_OUTPUT
            echo "Cache disabled for branch: $BRANCH_NAME"
          fi

      - name: Generate cache date
        id: cache-date
        if: steps.cache-decision.outputs.use_cache == 'true'
        run: |
          # Use year-month for cache key to refresh monthly
          CACHE_DATE=$(date +"%Y-%m")
          echo "cache_date=${CACHE_DATE}" >> $GITHUB_OUTPUT

      - name: Restore cache (dev branches only)
        id: cache-stage4
        if: steps.cache-decision.outputs.use_cache == 'true'
        uses: actions/cache/restore@v3
        with:
          path: stage4-base.tar.lz4
          key: stage4-${{ env.CACHE_VERSION }}-${{ steps.cache-date.outputs.cache_date }}-bookworm-arm64-lz4

      - name: Cache apt packages
        id: cache-apt
        uses: actions/cache@v3
        with:
          path: ~/apt-cache
          key: apt-packages-${{ runner.os }}-${{ hashFiles('.github/workflows/RQB-image.yaml') }}-v2

      - name: Install pi-gen dependencies
        run: |
          # Create our cache directory
          mkdir -p ~/apt-cache
          
          # If cache was restored, copy packages to apt's directory
          if [ "${{ steps.cache-apt.outputs.cache-hit }}" == "true" ]; then
            echo "Restoring apt packages from cache..."
            sudo cp -n ~/apt-cache/*.deb /var/cache/apt/archives/ 2>/dev/null || true
          fi
          
          # Update package lists
          sudo apt-get update
          
          # Install packages (will use local cache if available)
          sudo apt-get install -y \
            coreutils \
            quilt \
            parted \
            qemu-user-static \
            debootstrap \
            zerofree \
            zip \
            dosfstools \
            libarchive-tools \
            libcap2-bin \
            grep \
            rsync \
            xz-utils \
            file \
            git \
            curl \
            bc \
            gpg \
            pigz \
            lz4 \
            arch-test
          
          # Save any new packages to our cache directory
          if [ "${{ steps.cache-apt.outputs.cache-hit }}" != "true" ]; then
            echo "Saving apt packages to cache..."
            cp /var/cache/apt/archives/*.deb ~/apt-cache/ 2>/dev/null || true
          fi

      - name: Clone pi-gen
        run: |
          git clone --depth 1 --branch arm64 https://github.com/RPi-Distro/pi-gen
          cd pi-gen

      - name: Copy custom stage
        run: cp -r stage-RQB2 pi-gen/

      - name: Configure build
        run: |
          cd pi-gen
          cat > config <<EOF
          IMG_NAME=rasqberry
          RELEASE=bookworm
          DEPLOY_COMPRESSION=xz
          COMPRESSION_LEVEL=8
          LOCALE_DEFAULT=en_GB.UTF-8
          TARGET_HOSTNAME=rasqberry
          KEYBOARD_KEYMAP=gb
          KEYBOARD_LAYOUT="English (UK)"
          TIMEZONE_DEFAULT=Europe/London
          FIRST_USER_NAME=rasqberry
          FIRST_USER_PASS="Qiskit1!"
          ENABLE_SSH=1
          DISABLE_FIRST_BOOT_USER_RENAME=1
          PUBKEY_ONLY_SSH=0
          WPA_COUNTRY=GB
          EOF

      - name: Build base stages (if not cached or cache disabled)
        if: steps.cache-decision.outputs.use_cache == 'false' || steps.cache-stage4.outputs.cache-matched-key == ''
        run: |
          cd pi-gen
          echo "Building base stages 0-4..."
          echo 'STAGE_LIST="stage0 stage1 stage2 stage3 stage4"' >> config
          
          # Skip Export for stages 0-4
          touch ./stage0/SKIP_IMAGES ./stage1/SKIP_IMAGES ./stage2/SKIP_IMAGES ./stage3/SKIP_IMAGES ./stage4/SKIP_IMAGES
          
          # Skip stage5 (not needed)
          touch ./stage5/SKIP
          
          # Run build
          sudo ./build.sh
          
          # Save the work directory state for cache
          if [ "${{ steps.cache-decision.outputs.use_cache }}" == "true" ]; then
            echo "Saving work directory for cache..."
            
            # Find the actual work directory (could be timestamped or just 'rasqberry')
            WORK_DIR=$(find work -maxdepth 1 -type d ! -name work | head -1)
            echo "Found work directory: $WORK_DIR"
            
            # Ensure stage4 rootfs exists and copy it for the next stage
            if [ -d "$WORK_DIR/stage4/rootfs" ]; then
              sudo mkdir -p work/.cache-stage4
              sudo cp -al $WORK_DIR/stage4/rootfs work/.cache-stage4/
              echo "Copied stage4 rootfs to cache directory"
            else
              echo "WARNING: stage4 rootfs not found at $WORK_DIR/stage4/rootfs"
            fi

            sudo tar -cf - \
              --exclude='work/*/stage*/rootfs/var/cache/apt/archives/*.deb' \
              --exclude='work/*/stage*/rootfs/tmp/*' \
              --exclude='work/*/stage*/rootfs/var/log/*' \
              --exclude='work/*/stage*/rootfs/var/cache/apt/*.bin' \
              --exclude='work/*/stage*/rootfs/var/lib/apt/lists/*' \
              --exclude='work/*/stage*/rootfs/home/*/.cache/*' \
              --exclude='work/*/stage*/rootfs/**/__pycache__' \
              --exclude='work/*/stage*/rootfs/**/*.pyc' \
              --exclude='work/*/stage*/rootfs/**/*.pyo' \
              --exclude='work/*/stage*/rootfs/usr/src/*' \
              --exclude='work/*/stage*/rootfs/var/cache/debconf/*' \
              --exclude='work/*/stage*/rootfs/boot/*.old' \
              --exclude='work/*/stage*/rootfs/var/cache/pip/*' \
              work | lz4 -1 > ../stage4-base.tar.lz4
            
            # Move back to workspace root to verify the file
            cd ..
            if [ -f "stage4-base.tar.lz4" ]; then
              echo "âœ“ Cache file created successfully at workspace root"
              echo "Cache size: $(du -h stage4-base.tar.lz4 | cut -f1)"
              echo "Cache location: $(pwd)/stage4-base.tar.lz4"
              ls -la stage4-base.tar.lz4
            else
              echo "ERROR: Cache file not found at expected location!"
              echo "Current directory: $(pwd)"
              echo "Looking for stage4-base.tar.lz4:"
              find . -name "stage4-base.tar.lz4" -type f 2>/dev/null || echo "File not found anywhere"
              exit 1
            fi
          fi
          
          # Clean up to prepare for custom stage
          cd pi-gen  # Go back to pi-gen directory
          sudo rm -rf work/*/stage-RQB2 || true

      - name: Save cache
        if: steps.cache-decision.outputs.use_cache == 'true' && steps.cache-stage4.outputs.cache-matched-key == ''
        uses: actions/cache/save@v3
        with:
          path: stage4-base.tar.lz4
          key: stage4-${{ env.CACHE_VERSION }}-${{ steps.cache-date.outputs.cache_date }}-bookworm-arm64-lz4

      - name: Restore cached build
        if: steps.cache-stage4.outputs.cache-matched-key != ''
        run: |
          cd pi-gen
          echo "Restoring cached build..."
          lz4 -dc ../stage4-base.tar.lz4 | sudo tar -xf -
          
          # Verify the extraction worked
          WORK_DIR=$(find work -maxdepth 1 -type d ! -name work | head -1)
          echo "Found work directory: $WORK_DIR"
          
          if [ -d "$WORK_DIR/stage4/rootfs" ]; then
            ROOTFS_SIZE=$(sudo du -s "$WORK_DIR/stage4/rootfs" | cut -f1)
            echo "Restored rootfs size: $ROOTFS_SIZE KB"
            if [ "$ROOTFS_SIZE" -lt 1000 ]; then
              echo "ERROR: Rootfs appears incomplete (only $ROOTFS_SIZE KB)"
              exit 1
            fi
          else
            echo "ERROR: No rootfs found in restored cache!"
            exit 1
          fi
          
          # Clean up any temporary cache directory if it exists
          sudo rm -rf work/.cache-stage4 || true

      - name: Debug cache structure
        if: steps.cache-stage4.outputs.cache-matched-key != ''
        run: |
          cd pi-gen
          echo "=== Work directory structure ==="
          find work -type d -name "stage*" | head -20
          echo "=== Looking for rootfs ==="
          find work -type d -name "rootfs" | head -5
          echo "=== Looking for .build_done markers ==="
          find work -name ".build_done" | head -10
          echo "=== Work directory listing ==="
          ls -la work/
          if [ -d "work/.cache-stage4" ]; then
            echo "=== Cache stage4 directory exists ==="
            ls -la work/.cache-stage4/
          fi

      - name: Build custom stage
        run: |
          cd pi-gen
          
          # Check if we should use cache and if cache was hit
          if [ "${{ steps.cache-decision.outputs.use_cache }}" == "true" ] && [ "${{ steps.cache-stage4.outputs.cache-matched-key }}" != "" ]; then
            echo "Using cached base stages..."
            
            # Find the work directory
            WORK_DIR=$(find work -maxdepth 1 -type d ! -name work | head -1)
            
            if [ -n "$WORK_DIR" ]; then
              echo "Found work directory: $WORK_DIR"
              
              # Check if stage4 rootfs exists
              if [ ! -d "$WORK_DIR/stage4/rootfs" ]; then
                echo "ERROR: stage4/rootfs missing from cache!"
                echo "This cache is incomplete. Please use workflow_dispatch with 'refresh_cache' to rebuild."
                exit 1
              fi
              
              # Get the absolute path to the work directory
              WORK_NAME=$(basename "$WORK_DIR")
              WORK_DIR_ABS="$(pwd)/work/$WORK_NAME"
              
              # Create the build.log file that pi-gen expects
              sudo touch "$WORK_DIR_ABS/build.log"
              
              # Ensure all previous stages have proper markers
              for stage in stage0 stage1 stage2 stage3 stage4; do
                if [ ! -f "$WORK_DIR_ABS/$stage/.build_done" ]; then
                  echo "Creating $stage build marker..."
                  sudo mkdir -p "$WORK_DIR_ABS/$stage"
                  sudo touch "$WORK_DIR_ABS/$stage/.build_done"
                fi
              done
              
              # Create SKIP files for stages we don't want to rebuild
              for stage in stage0 stage1 stage2 stage3 stage4; do
                sudo touch "$WORK_DIR_ABS/$stage/SKIP"
              done
              
              # Set up the main config for continuation
              echo "CONTINUE=1" >> config
              echo "WORK_DIR=$WORK_DIR_ABS" >> config
              echo 'STAGE_LIST="stage0 stage1 stage2 stage3 stage4 ./stage-RQB2"' >> config
              
            else
              echo "ERROR: No work directory found!"
              exit 1
            fi
          else
            echo "Continuing from fresh base build..."
            
            # For fresh build continuation, we need to modify the existing config
            # Remove the old STAGE_LIST that includes stages 0-4
            sed -i '/^STAGE_LIST=/d' config
            
            # Add the custom stage configuration
            echo "CONTINUE=1" >> config
            echo 'STAGE_LIST="./stage-RQB2"' >> config
          fi
          
          # Debug: Show final config
          echo "=== Final config file ==="
          cat config
          echo "========================"
          
          # Ensure the chroot has proper package sources
          if [ "${{ steps.cache-decision.outputs.use_cache }}" == "true" ] && [ "${{ steps.cache-stage4.outputs.cache-matched-key }}" != "" ]; then
            echo "Ensuring package sources in cached rootfs..."
            
            # Check if sources.list exists
            if [ -f "$WORK_DIR_ABS/stage4/rootfs/etc/apt/sources.list" ]; then
              echo "sources.list exists"
              sudo cat "$WORK_DIR_ABS/stage4/rootfs/etc/apt/sources.list"
            else
              echo "WARNING: sources.list missing in rootfs!"
            fi
            
            # Update package lists in the rootfs
            sudo chroot "$WORK_DIR_ABS/stage4/rootfs" apt-get update || echo "Failed to update package lists in chroot"
          fi

          # Build custom stage
          sudo ./build.sh

      - name: Set dynamic asset path and name
        id: set-asset
        run: |
          cd pi-gen
          mkdir -p ../deploy
          
          # Find the final image
          FINAL_IMAGE=$(find deploy -name "*.img.xz" -type f | head -n 1)
          
          if [ -z "$FINAL_IMAGE" ]; then
            echo "Error: No image found in deploy directory"
            exit 1
          fi
          
          # Copy to deploy folder
          cp "$FINAL_IMAGE" ../deploy/
          
          # Set outputs
          FILE_NAME=$(basename "$FINAL_IMAGE")
          echo "asset_path=deploy/$FILE_NAME" >> $GITHUB_OUTPUT
          echo "asset_name=$FILE_NAME" >> $GITHUB_OUTPUT
          
          # Show file info
          echo "Built image: $FILE_NAME"
          echo "Size: $(du -h ../deploy/$FILE_NAME | cut -f1)"
          
          # Log cache usage
          if [ "${{ steps.cache-decision.outputs.use_cache }}" == "true" ]; then
            echo "Build completed with caching enabled"
            if [ "${{ steps.cache-stage4.outputs.cache-matched-key }}" != "" ]; then
              echo "Cache was used - only custom stage was rebuilt"
            else
              echo "Cache miss - full build was performed"
            fi
          else
            echo "Build completed without caching (production build)"
          fi

      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.release.outputs.upload_url }}
          asset_path: ${{ steps.set-asset.outputs.asset_path }}
          asset_name: ${{ steps.set-asset.outputs.asset_name }}
          asset_content_type: application/x-xz