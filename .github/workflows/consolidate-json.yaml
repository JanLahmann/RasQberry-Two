# ============================================================================
# RQB-images.json Consolidation Workflow
# ============================================================================
# Purpose: Consolidates RQB-images.json from multiple branches into a single
#          hierarchical file on gh-pages for use by Raspberry Pi Imager.
#
# Architecture:
#   Each branch (main, beta, dev*) maintains its own RQB-images.json with both
#   standard and A/B image entries (marked with "image_type" field).
#
#   This workflow fetches from all branches and builds a hierarchical structure:
#   - Top-level: Main stable (std), Beta (std)
#   - "RasQberry Development Images" folder: All dev std images
#   - "RasQberry A/B Boot Images" folder: All A/B images (main, beta, dev)
#   - Raspberry Pi OS (64-bit)
#   - Use custom image
#
# Trigger:
#   - Automatically triggered after image builds complete
#   - Scheduled daily to detect deleted releases
#   - On release deletion events
#   - Can also be triggered manually for debugging
# ============================================================================

name: Consolidate RQB-images.json

on:
  # Scheduled: Run daily at 6 AM UTC to detect stale/deleted releases
  schedule:
    - cron: '0 6 * * *'

  # Trigger on release deletion
  release:
    types: [deleted]

  workflow_dispatch:
    inputs:
      trigger_source:
        description: 'Branch that triggered this workflow'
        required: false
        type: string
        default: 'manual'
      trigger_type:
        description: 'Type of release that triggered (main/beta/dev)'
        required: false
        type: string
        default: 'unknown'
      skip_validation:
        description: 'Skip URL validation (faster but may include stale releases)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  consolidate:
    name: Consolidate JSON from all branches
    runs-on: ubuntu-latest

    steps:
      - name: Checkout gh-pages
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          fetch-depth: 0

      - name: Fetch RQB-images.json from all branches
        id: fetch
        run: |
          echo "=== Consolidating RQB-images.json from all branches ==="
          echo "Triggered by: ${{ github.event.inputs.trigger_source }} (${{ github.event.inputs.trigger_type }})"
          echo ""

          mkdir -p /tmp/branch-json

          # Function to fetch JSON from a branch
          fetch_branch_json() {
            local branch="$1"
            local output="/tmp/branch-json/${branch}.json"

            echo "Fetching from branch: $branch"
            if curl -s -f "https://raw.githubusercontent.com/${{ github.repository }}/${branch}/RQB-images.json" -o "$output"; then
              echo "  âœ“ Found RQB-images.json in $branch"
              return 0
            else
              echo "  âš  No RQB-images.json in $branch (or branch doesn't exist)"
              return 1
            fi
          }

          # Fetch from main branches
          fetch_branch_json "main" || true
          fetch_branch_json "beta" || true

          # Fetch from all dev branches for consolidation
          echo ""
          echo "Looking for dev branches..."

          # Get list of remote branches starting with 'dev'
          DEV_BRANCHES=$(git ls-remote --heads origin 'refs/heads/dev*' | sed 's|.*refs/heads/||' | head -10)

          if [ -n "$DEV_BRANCHES" ]; then
            echo "Found dev branches: $DEV_BRANCHES"
            for branch in $DEV_BRANCHES; do
              fetch_branch_json "$branch" || true  # Continue on failure, fetch all available
            done
          else
            echo "  âš  No dev branches found"
          fi

          echo ""
          echo "=== Fetched JSON files ==="
          ls -la /tmp/branch-json/ || echo "No files fetched"

      - name: Fetch official Raspberry Pi OS metadata
        id: raspios
        run: |
          echo "Fetching official Raspberry Pi OS metadata..."

          # Fetch from official Raspberry Pi Imager JSON
          # This is the same source Pi Imager uses
          curl -s -f "https://downloads.raspberrypi.com/os_list_imagingutility_v3.json" -o /tmp/rpi-official.json

          if [ -f /tmp/rpi-official.json ]; then
            echo "âœ“ Fetched official Raspberry Pi OS list"
          else
            echo "âš  Failed to fetch official list, will use fallback"
          fi

      - name: Merge JSON files
        env:
          SKIP_VALIDATION: ${{ github.event.inputs.skip_validation || 'false' }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import urllib.request
          import os
          import re
          from pathlib import Path

          print("=== Merging RQB-images.json files into hierarchical structure ===")

          # URL Validation function
          def validate_release_url(url):
              """Check if a GitHub release URL is still accessible."""
              if not url:
                  return False, "No URL provided"

              # Skip validation if requested
              if os.environ.get('SKIP_VALIDATION', 'false').lower() == 'true':
                  return True, "Validation skipped"

              try:
                  # For GitHub release URLs, use the API to check if the release exists
                  # URL format: https://github.com/OWNER/REPO/releases/download/TAG/filename
                  github_pattern = r'https://github\.com/([^/]+)/([^/]+)/releases/download/([^/]+)/'
                  match = re.match(github_pattern, url)

                  if match:
                      owner, repo, tag = match.groups()
                      api_url = f"https://api.github.com/repos/{owner}/{repo}/releases/tags/{tag}"

                      req = urllib.request.Request(api_url)
                      token = os.environ.get('GITHUB_TOKEN')
                      if token:
                          req.add_header('Authorization', f'token {token}')
                      req.add_header('Accept', 'application/vnd.github.v3+json')

                      with urllib.request.urlopen(req, timeout=10) as response:
                          if response.status == 200:
                              return True, "Release exists"
                  else:
                      # For non-GitHub URLs, do a HEAD request
                      req = urllib.request.Request(url, method='HEAD')
                      with urllib.request.urlopen(req, timeout=10) as response:
                          if response.status in [200, 302, 307]:
                              return True, "URL accessible"

                  return False, "URL not accessible"

              except urllib.error.HTTPError as e:
                  if e.code == 404:
                      return False, f"Release not found (404)"
                  return False, f"HTTP error: {e.code}"
              except Exception as e:
                  # On error, assume URL is valid to avoid false negatives
                  print(f"  âš  Validation error for {url}: {e}")
                  return True, f"Validation error (assuming valid): {e}"

          # Collect entries by category
          main_std = []      # Main stable standard images (top-level)
          beta_std = []      # Beta standard images (top-level)
          dev_std = []       # Dev standard images (folder)
          ab_images = []     # All A/B images (folder)
          skipped_entries = []  # Track skipped entries for reporting

          json_dir = Path("/tmp/branch-json")

          # Load and classify entries from each branch's JSON
          for json_file in json_dir.glob("*.json"):
              branch_name = json_file.stem
              print(f"\nProcessing: {branch_name}")

              try:
                  with open(json_file, 'r') as f:
                      data = json.load(f)

                  for entry in data.get('os_list', []):
                      name = entry.get('name', '')
                      image_type = entry.get('image_type', 'standard')
                      url = entry.get('url', '')

                      # Only include RasQberry entries
                      if 'RasQberry' not in name:
                          continue

                      # Validate that the release URL still exists
                      is_valid, validation_msg = validate_release_url(url)
                      if not is_valid:
                          print(f"  âœ— SKIPPED (release deleted): {name}")
                          print(f"    URL: {url}")
                          print(f"    Reason: {validation_msg}")
                          skipped_entries.append({
                              'branch': branch_name,
                              'name': name,
                              'url': url,
                              'reason': validation_msg
                          })
                          continue

                      # Remove internal image_type field before adding to output
                      entry_clean = {k: v for k, v in entry.items() if k != 'image_type'}

                      # Classify by BRANCH NAME (not image name) for proper categorization
                      # Dev images: add branch identifier to distinguish them
                      if image_type == 'ab' or 'A/B' in name:
                          # Add branch name to make A/B images distinguishable
                          entry_clean['name'] = f"RasQberry Two A/B ({branch_name})"
                          entry_clean['description'] = f"A/B boot image from {branch_name}"
                          ab_images.append((entry.get('release_date', ''), branch_name, entry_clean))
                          print(f"  â†’ A/B folder: {entry_clean['name']}")
                      elif branch_name.startswith('dev'):
                          # Add branch name to make dev images distinguishable
                          entry_clean['name'] = f"RasQberry Two Dev ({branch_name})"
                          entry_clean['description'] = f"Development build from {branch_name}"
                          dev_std.append((entry.get('release_date', ''), branch_name, entry_clean))
                          print(f"  â†’ Dev folder: {entry_clean['name']}")
                      elif branch_name == 'beta':
                          # Beta branch â†’ top-level beta entry
                          entry_clean['name'] = "RasQberry Two Beta (64-bit)"
                          entry_clean['description'] = "Beta release with new features for testing"
                          beta_std.append((entry.get('release_date', ''), branch_name, entry_clean))
                          print(f"  â†’ Top-level Beta: {entry_clean['name']}")
                      elif branch_name == 'main':
                          # Main branch: only stable if name doesn't contain "Dev"
                          if 'Dev' in name:
                              # Main has dev image - put in dev folder
                              entry_clean['name'] = f"RasQberry Two Dev ({branch_name})"
                              entry_clean['description'] = f"Development build from {branch_name}"
                              dev_std.append((entry.get('release_date', ''), branch_name, entry_clean))
                              print(f"  â†’ Dev folder (main has dev): {entry_clean['name']}")
                          else:
                              # Main has stable release
                              entry_clean['name'] = "RasQberry Two (64-bit)"
                              entry_clean['description'] = "Stable release for Raspberry Pi 4/5 (Recommended)"
                              main_std.append((entry.get('release_date', ''), branch_name, entry_clean))
                              print(f"  â†’ Top-level Main: {entry_clean['name']}")
                      else:
                          # Unknown branch pattern - treat as dev
                          entry_clean['name'] = f"RasQberry Two ({branch_name})"
                          dev_std.append((entry.get('release_date', ''), branch_name, entry_clean))
                          print(f"  â†’ Dev folder (unknown): {entry_clean['name']}")

              except Exception as e:
                  print(f"  Error loading {json_file}: {e}")

          # Sort each category by release_date (newest first)
          main_std.sort(key=lambda x: x[0], reverse=True)
          beta_std.sort(key=lambda x: x[0], reverse=True)
          dev_std.sort(key=lambda x: x[0], reverse=True)
          ab_images.sort(key=lambda x: x[0], reverse=True)

          # Build hierarchical os_list
          os_list = []

          # 1. Add main stable images (top-level) - only latest
          if main_std:
              os_list.append(main_std[0][2])
              print(f"\nâœ“ Added main stable: {main_std[0][2].get('name')}")

          # 2. Add beta images (top-level) - only latest
          if beta_std:
              os_list.append(beta_std[0][2])
              print(f"âœ“ Added beta: {beta_std[0][2].get('name')}")

          # 3. Add Development Images folder (if any dev images exist)
          if dev_std:
              dev_folder = {
                  "name": "RasQberry Development Images",
                  "description": "Development builds with cutting-edge features (unstable)",
                  "icon": "https://rasqberry.org/Artwork/RasQberry 2 Logo Cube 64x64.png",
                  "subitems": [entry for _, _, entry in dev_std]
              }
              os_list.append(dev_folder)
              print(f"âœ“ Added Development folder with {len(dev_std)} images")

          # 4. Add A/B Test Images folder (if any AB images exist)
          if ab_images:
              ab_folder = {
                  "name": "RasQberry A/B Boot Images",
                  "description": "Images with A/B partition support for safer updates",
                  "icon": "https://rasqberry.org/Artwork/RasQberry 2 Logo Cube 64x64.png",
                  "subitems": [entry for _, _, entry in ab_images]
              }
              os_list.append(ab_folder)
              print(f"âœ“ Added A/B folder with {len(ab_images)} images")

          # Build final consolidated structure
          consolidated = {
              "imager": {
                  "latest_version": "1.8.5",
                  "url": "https://www.raspberrypi.com/software/"
              },
              "os_list": os_list
          }

          print(f"\n=== Built hierarchical structure with {len(os_list)} top-level entries ===")

          # Fetch official Raspberry Pi OS entry from their JSON
          raspios_entry = None
          try:
              with open('/tmp/rpi-official.json', 'r') as f:
                  rpi_data = json.load(f)

              # Navigate the structure to find Raspberry Pi OS (64-bit)
              # The official JSON has nested structure with os_list containing subitems
              def find_raspios_64bit(items):
                  for item in items:
                      name = item.get('name', '')
                      # Look for the recommended 64-bit desktop version
                      if 'Raspberry Pi OS' in name and '64-bit' in name and 'Lite' not in name and 'Full' not in name:
                          # Check if it has direct download info or subitems
                          if 'url' in item:
                              return item
                          if 'subitems' in item:
                              # Look in subitems for the main desktop version
                              for sub in item['subitems']:
                                  sub_name = sub.get('name', '')
                                  if 'Desktop' in sub_name or ('64-bit' in sub_name and 'Lite' not in sub_name):
                                      if 'url' in sub:
                                          return sub
                      # Recurse into subitems
                      if 'subitems' in item:
                          result = find_raspios_64bit(item['subitems'])
                          if result:
                              return result
                  return None

              raspios_entry = find_raspios_64bit(rpi_data.get('os_list', []))

              if raspios_entry:
                  # Clean up the entry to match our schema
                  clean_entry = {
                      "name": raspios_entry.get('name', 'Raspberry Pi OS (64-bit)'),
                      "description": raspios_entry.get('description', 'Official Raspberry Pi OS'),
                      "icon": raspios_entry.get('icon', 'https://downloads.raspberrypi.com/raspios_armhf/Raspberry_Pi_OS_(32-bit).png'),
                      "url": raspios_entry.get('url'),
                      "extract_size": raspios_entry.get('extract_size'),
                      "extract_sha256": raspios_entry.get('extract_sha256'),
                      "image_download_size": raspios_entry.get('image_download_size'),
                      "release_date": raspios_entry.get('release_date'),
                      "init_format": raspios_entry.get('init_format', 'systemd'),
                      "devices": raspios_entry.get('devices', ['pi5-64bit', 'pi4-64bit'])
                  }
                  # Remove None values
                  clean_entry = {k: v for k, v in clean_entry.items() if v is not None}
                  consolidated['os_list'].append(clean_entry)
                  print(f"\nâœ“ Added official Raspberry Pi OS entry: {clean_entry.get('name')}")
                  print(f"  Release date: {clean_entry.get('release_date')}")
              else:
                  print("\nâš  Could not find Raspberry Pi OS (64-bit) in official JSON")
                  raise Exception("Fallback needed")

          except Exception as e:
              print(f"\nâš  Error fetching official Raspberry Pi OS: {e}")
              print("  Using fallback entry (may be outdated)")
              # Fallback to a known working entry
              consolidated['os_list'].append({
                  "name": "Raspberry Pi OS (64-bit)",
                  "description": "A port of Debian Bookworm with the Raspberry Pi Desktop (Recommended)",
                  "icon": "https://downloads.raspberrypi.com/raspios_armhf/Raspberry_Pi_OS_(32-bit).png",
                  "url": "https://downloads.raspberrypi.com/raspios_arm64/images/raspios_arm64-2024-10-28/2024-10-22-raspios-bookworm-arm64.img.xz",
                  "extract_size": 6102712320,
                  "extract_sha256": "88093218a66cf20e8669963902a949c4c23b73309c2fc3331d09fa6ee2134417",
                  "image_download_size": 1238664180,
                  "release_date": "2024-10-22",
                  "init_format": "systemd",
                  "devices": ["pi5-64bit", "pi4-64bit"]
              })

          # Note: Pi Imager has built-in "Use custom" option, no need to add our own

          # Report skipped entries (deleted releases)
          if skipped_entries:
              print("\n" + "="*60)
              print("âš  SKIPPED ENTRIES (releases no longer exist):")
              print("="*60)
              for entry in skipped_entries:
                  print(f"\n  Branch: {entry['branch']}")
                  print(f"  Name:   {entry['name']}")
                  print(f"  URL:    {entry['url']}")
                  print(f"  Reason: {entry['reason']}")
              print("\n" + "="*60)
              print(f"Total skipped: {len(skipped_entries)} entries")
              print("These branches have stale RQB-images.json files that should be updated.")
              print("="*60)

          # Write consolidated JSON to public folder (where website serves from)
          with open('public/RQB-images.json', 'w') as f:
              json.dump(consolidated, f, indent=2)

          print("\n=== Final RQB-images.json ===")
          print(json.dumps(consolidated, indent=2))

          # Write skipped entries to a separate file for reference
          if skipped_entries:
              with open('/tmp/skipped-releases.json', 'w') as f:
                  json.dump(skipped_entries, f, indent=2)
          PYTHON_SCRIPT

      - name: Commit consolidated JSON to gh-pages
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          git add public/RQB-images.json

          # Check if there are changes
          if git diff --staged --quiet; then
            echo "No changes to public/RQB-images.json"
          else
            git commit -m "Consolidate RQB-images.json from all branches (triggered by ${{ github.event.inputs.trigger_source }})"
            git push origin gh-pages
            echo "âœ“ Consolidated RQB-images.json committed to gh-pages"
          fi

      - name: Summary
        run: |
          echo "=== Consolidation Complete ==="
          echo ""
          echo "Trigger: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" = "schedule" ]; then
            echo "  (Scheduled daily validation run)"
          elif [ "${{ github.event_name }}" = "release" ]; then
            echo "  (Release deletion detected)"
          fi
          echo ""
          echo "Validation: ${{ github.event.inputs.skip_validation == 'true' && 'SKIPPED' || 'ENABLED' }}"
          echo ""
          echo "RQB-images.json on gh-pages now has hierarchical structure:"
          echo ""
          echo "First Page (top-level):"
          echo "  â”œâ”€â”€ RasQberry Two (64-bit)         - Main stable"
          echo "  â”œâ”€â”€ RasQberry Two Beta (64-bit)    - Beta release"
          echo "  â”œâ”€â”€ ðŸ“ RasQberry Development Images  - Dev builds folder"
          echo "  â”œâ”€â”€ ðŸ“ RasQberry A/B Boot Images     - A/B images folder"
          echo "  â”œâ”€â”€ Raspberry Pi OS (64-bit)       - Official Pi OS"
          echo "  â””â”€â”€ Use custom image"
          echo ""
          # Report skipped entries if any
          if [ -f /tmp/skipped-releases.json ]; then
            echo "âš  WARNING: Some releases were skipped (deleted from GitHub):"
            cat /tmp/skipped-releases.json
            echo ""
          fi
          echo ""
          echo "Access the consolidated file at:"
          echo "  https://raw.githubusercontent.com/${{ github.repository }}/gh-pages/public/RQB-images.json"
          echo ""
          echo "Or configure Pi Imager with:"
          echo "  https://janlahmann.github.io/RasQberry-Two/RQB-images.json"
