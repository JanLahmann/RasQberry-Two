# ============================================================================
# RQB JSON Consolidation Workflow
# ============================================================================
# Purpose: Consolidates JSON files from multiple branches into gh-pages:
#          1. RQB-images.json - Hierarchical structure for Raspberry Pi Imager
#          2. RQB-releases.json - Stream-based structure for website /latest/ page
#
# Architecture:
#   Each branch (main, beta, dev*) maintains its own RQB-images.json with both
#   standard and A/B image entries (marked with "image_type" field).
#
#   This workflow fetches from all branches and builds:
#
#   RQB-images.json (Pi Imager):
#   - Top-level: Main stable (std), Beta (std)
#   - "RasQberry Development Images" folder:
#       - Main dev branches (dev-featuresXX)
#       - "Other Development Builds" sub-folder (sub-branches like dev-features05-fix)
#   - "RasQberry A/B Boot Images" folder:
#       - Main A/B images
#       - "Other A/B Builds" sub-folder (sub-branches)
#   - Raspberry Pi OS (64-bit)
#
#   Sub-branch images (e.g., dev-features05-fix, dev-features05-SAP) are loaded
#   from RQB-images-all.json to match the /latest website display.
#
#   RQB-releases.json (Website):
#   - streams.stable: Latest main release (or placeholder if none)
#   - streams.beta: Latest beta release (or placeholder if none)
#   - streams.dev: Latest dev release from newest dev branch
#
# Trigger:
#   - Automatically triggered after image builds complete
#   - Scheduled every 8 hours to detect deleted releases
#   - On release deletion events
#   - Can also be triggered manually for debugging
# ============================================================================

name: Consolidate RQB JSON files

on:
  # Scheduled: Run every 8 hours (0:00, 8:00, 16:00 UTC) to detect stale/deleted releases
  schedule:
    - cron: '0 */8 * * *'

  # Trigger on release deletion
  release:
    types: [deleted]

  workflow_dispatch:
    inputs:
      trigger_source:
        description: 'Branch that triggered this workflow'
        required: false
        type: string
        default: 'manual'
      trigger_type:
        description: 'Type of release that triggered (main/beta/dev)'
        required: false
        type: string
        default: 'unknown'
      skip_validation:
        description: 'Skip URL validation (faster but may include stale releases)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  actions: write

jobs:
  consolidate:
    name: Consolidate JSON from all branches
    runs-on: ubuntu-latest

    steps:
      - name: Checkout gh-pages
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          fetch-depth: 0

      - name: Fetch RQB-images.json from all branches
        id: fetch
        run: |
          echo "=== Consolidating RQB-images.json from all branches ==="
          echo "Triggered by: ${{ github.event.inputs.trigger_source }} (${{ github.event.inputs.trigger_type }})"
          echo ""

          mkdir -p /tmp/branch-json

          # Function to fetch JSON from a branch
          fetch_branch_json() {
            local branch="$1"
            local output="/tmp/branch-json/${branch}.json"

            echo "Fetching from branch: $branch"
            if curl -s -f "https://raw.githubusercontent.com/${{ github.repository }}/${branch}/RQB-images.json" -o "$output"; then
              echo "  ‚úì Found RQB-images.json in $branch"
              return 0
            else
              echo "  ‚ö† No RQB-images.json in $branch (or branch doesn't exist)"
              return 1
            fi
          }

          # Fetch from main branches
          fetch_branch_json "main" || true
          fetch_branch_json "beta" || true

          # Fetch from main dev-features branches only (dev-featuresXX pattern)
          # Excludes sub-branches like dev-features03-norelease, dev-features03-SAP, etc.
          echo ""
          echo "Looking for dev-features branches..."

          # Get list of dev-features branches matching pattern dev-featuresXX (exactly 2 digits, no suffix)
          DEV_BRANCHES=$(git ls-remote --heads origin 'refs/heads/dev-features*' \
            | sed 's|.*refs/heads/||' \
            | grep -E '^dev-features[0-9]{2}$' \
            | sort -V -r \
            | head -5)

          if [ -n "$DEV_BRANCHES" ]; then
            echo "Found dev-features branches: $DEV_BRANCHES"
            for branch in $DEV_BRANCHES; do
              fetch_branch_json "$branch" || true  # Continue on failure, fetch all available
            done
          else
            echo "  ‚ö† No dev-features branches found"
          fi

          echo ""
          echo "=== Fetched JSON files ==="
          ls -la /tmp/branch-json/ || echo "No files fetched"

      - name: Fetch official Raspberry Pi OS metadata
        id: raspios
        run: |
          echo "Fetching official Raspberry Pi OS metadata..."

          # Fetch from official Raspberry Pi Imager JSON
          # This is the same source Pi Imager uses
          curl -s -f "https://downloads.raspberrypi.com/os_list_imagingutility_v3.json" -o /tmp/rpi-official.json

          if [ -f /tmp/rpi-official.json ]; then
            echo "‚úì Fetched official Raspberry Pi OS list"
          else
            echo "‚ö† Failed to fetch official list, will use fallback"
          fi

      - name: Merge JSON files
        env:
          SKIP_VALIDATION: ${{ github.event.inputs.skip_validation || 'false' }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import urllib.request
          import os
          import re
          from pathlib import Path

          print("=== Merging RQB-images.json files into hierarchical structure ===")

          # URL Validation function
          def validate_release_url(url):
              """Check if a GitHub release URL is still accessible."""
              if not url:
                  return False, "No URL provided"

              # Skip validation if requested
              if os.environ.get('SKIP_VALIDATION', 'false').lower() == 'true':
                  return True, "Validation skipped"

              try:
                  # For GitHub release URLs, use the API to check if the release exists
                  # URL format: https://github.com/OWNER/REPO/releases/download/TAG/filename
                  github_pattern = r'https://github\.com/([^/]+)/([^/]+)/releases/download/([^/]+)/'
                  match = re.match(github_pattern, url)

                  if match:
                      owner, repo, tag = match.groups()
                      api_url = f"https://api.github.com/repos/{owner}/{repo}/releases/tags/{tag}"

                      req = urllib.request.Request(api_url)
                      token = os.environ.get('GITHUB_TOKEN')
                      if token:
                          req.add_header('Authorization', f'token {token}')
                      req.add_header('Accept', 'application/vnd.github.v3+json')

                      with urllib.request.urlopen(req, timeout=10) as response:
                          if response.status == 200:
                              return True, "Release exists"
                  else:
                      # For non-GitHub URLs, do a HEAD request
                      req = urllib.request.Request(url, method='HEAD')
                      with urllib.request.urlopen(req, timeout=10) as response:
                          if response.status in [200, 302, 307]:
                              return True, "URL accessible"

                  return False, "URL not accessible"

              except urllib.error.HTTPError as e:
                  if e.code == 404:
                      return False, f"Release not found (404)"
                  return False, f"HTTP error: {e.code}"
              except Exception as e:
                  # On error, assume URL is valid to avoid false negatives
                  print(f"  ‚ö† Validation error for {url}: {e}")
                  return True, f"Validation error (assuming valid): {e}"

          # Collect entries by category
          main_std = []      # Main stable standard images (top-level)
          beta_std = []      # Beta standard images (top-level)
          dev_std = []       # Dev standard images (main branches)
          dev_sub = []       # Dev standard images (sub-branches, nested folder)
          ab_images = []     # A/B images (main branches)
          ab_sub = []        # A/B images (sub-branches, nested folder)
          skipped_entries = []  # Track skipped entries for reporting
          processed_urls = set()  # Track already processed URLs to avoid duplicates

          json_dir = Path("/tmp/branch-json")

          # Load and classify entries from each branch's JSON
          for json_file in json_dir.glob("*.json"):
              branch_name = json_file.stem
              print(f"\nProcessing: {branch_name}")

              try:
                  with open(json_file, 'r') as f:
                      data = json.load(f)

                  for entry in data.get('os_list', []):
                      name = entry.get('name', '')
                      image_type = entry.get('image_type', 'standard')
                      url = entry.get('url', '')

                      # Only include RasQberry entries
                      if 'RasQberry' not in name:
                          continue

                      # Validate that the release URL still exists
                      is_valid, validation_msg = validate_release_url(url)
                      if not is_valid:
                          print(f"  ‚úó SKIPPED (release deleted): {name}")
                          print(f"    URL: {url}")
                          print(f"    Reason: {validation_msg}")
                          skipped_entries.append({
                              'branch': branch_name,
                              'name': name,
                              'url': url,
                              'reason': validation_msg
                          })
                          continue

                      # Remove internal image_type field before adding to output
                      entry_clean = {k: v for k, v in entry.items() if k != 'image_type'}

                      # Track URL to avoid duplicates when adding sub-branch images later
                      processed_urls.add(url)

                      # Classify by BRANCH NAME (not image name) for proper categorization
                      # Dev images: add branch identifier to distinguish them
                      if image_type == 'ab' or 'A/B' in name:
                          # Add branch name to make A/B images distinguishable
                          entry_clean['name'] = f"RasQberry Two A/B ({branch_name})"
                          entry_clean['description'] = f"A/B boot image from {branch_name}"
                          ab_images.append((entry.get('release_date', ''), branch_name, entry_clean))
                          print(f"  ‚Üí A/B folder: {entry_clean['name']}")
                      elif branch_name.startswith('dev'):
                          # Add branch name to make dev images distinguishable
                          entry_clean['name'] = f"RasQberry Two Dev ({branch_name})"
                          entry_clean['description'] = f"Development build from {branch_name}"
                          dev_std.append((entry.get('release_date', ''), branch_name, entry_clean))
                          print(f"  ‚Üí Dev folder: {entry_clean['name']}")
                      elif branch_name == 'beta':
                          # Beta branch ‚Üí top-level beta entry
                          entry_clean['name'] = "RasQberry Two Beta (64-bit)"
                          entry_clean['description'] = "Beta release with new features for testing"
                          beta_std.append((entry.get('release_date', ''), branch_name, entry_clean))
                          print(f"  ‚Üí Top-level Beta: {entry_clean['name']}")
                      elif branch_name == 'main':
                          # Main branch: only stable if name doesn't contain "Dev"
                          if 'Dev' in name:
                              # Main has dev image - put in dev folder
                              entry_clean['name'] = f"RasQberry Two Dev ({branch_name})"
                              entry_clean['description'] = f"Development build from {branch_name}"
                              dev_std.append((entry.get('release_date', ''), branch_name, entry_clean))
                              print(f"  ‚Üí Dev folder (main has dev): {entry_clean['name']}")
                          else:
                              # Main has stable release
                              entry_clean['name'] = "RasQberry Two (64-bit)"
                              entry_clean['description'] = "Stable release for Raspberry Pi 4/5 (Recommended)"
                              main_std.append((entry.get('release_date', ''), branch_name, entry_clean))
                              print(f"  ‚Üí Top-level Main: {entry_clean['name']}")
                      else:
                          # Unknown branch pattern - treat as dev
                          entry_clean['name'] = f"RasQberry Two ({branch_name})"
                          dev_std.append((entry.get('release_date', ''), branch_name, entry_clean))
                          print(f"  ‚Üí Dev folder (unknown): {entry_clean['name']}")

              except Exception as e:
                  print(f"  Error loading {json_file}: {e}")

          # ================================================================
          # Load sub-branch images from RQB-images-all.json
          # These are images from branches like dev-features05-fix, dev-features05-SAP
          # that are not in the main dev-featuresXX branches
          # ================================================================
          print("\n=== Loading sub-branch images from RQB-images-all.json ===")
          try:
              all_images_path = Path("public/RQB-images-all.json")
              if all_images_path.exists():
                  with open(all_images_path, 'r') as f:
                      all_data = json.load(f)

                  sub_branch_count = 0
                  for entry in all_data.get('releases', []):
                      url = entry.get('url', '')
                      branch = entry.get('_branch', '')
                      image_type = entry.get('image_type', 'standard')

                      # Skip if already processed from main branches
                      if url in processed_urls:
                          continue

                      # Skip if not a sub-branch (main branches already handled)
                      # Sub-branches have format: dev-featuresXX-something
                      if not re.match(r'^dev-features\d{2}-.+$', branch):
                          continue

                      # Validate URL still exists
                      is_valid, validation_msg = validate_release_url(url)
                      if not is_valid:
                          print(f"  ‚úó SKIPPED (release deleted): {branch}")
                          skipped_entries.append({
                              'branch': branch,
                              'name': entry.get('name', ''),
                              'url': url,
                              'reason': validation_msg
                          })
                          continue

                      # Build clean entry
                      entry_clean = {
                          'name': f"RasQberry Two {'A/B' if image_type == 'ab' else 'Dev'} ({branch})",
                          'description': f"{'A/B boot' if image_type == 'ab' else 'Development'} build from {branch}",
                          'icon': entry.get('icon', 'https://rasqberry.org/Artwork/RasQberry 2 Logo Cube 64x64.png'),
                          'url': url,
                          'image_download_size': entry.get('image_download_size'),
                          'release_date': entry.get('release_date'),
                          'init_format': entry.get('init_format', 'systemd'),
                          'devices': entry.get('devices', ['pi5-64bit', 'pi4-64bit']),
                          'website': entry.get('website', 'https://rasqberry.org')
                      }
                      # Add optional fields
                      if entry.get('extract_size'):
                          entry_clean['extract_size'] = entry.get('extract_size')
                      if entry.get('extract_sha256'):
                          entry_clean['extract_sha256'] = entry.get('extract_sha256')

                      # Remove None values
                      entry_clean = {k: v for k, v in entry_clean.items() if v is not None}

                      # Add to sub-branch category (nested folders)
                      if image_type == 'ab':
                          ab_sub.append((entry.get('release_date', ''), branch, entry_clean))
                          print(f"  ‚Üí A/B sub-folder: {entry_clean['name']}")
                      else:
                          dev_sub.append((entry.get('release_date', ''), branch, entry_clean))
                          print(f"  ‚Üí Dev sub-folder: {entry_clean['name']}")

                      processed_urls.add(url)
                      sub_branch_count += 1

                  print(f"\n‚úì Added {sub_branch_count} sub-branch images from RQB-images-all.json")
              else:
                  print("  ‚ö† RQB-images-all.json not found, skipping sub-branch images")

          except Exception as e:
              print(f"  Error loading RQB-images-all.json: {e}")

          # Sort each category by release_date (newest first)
          main_std.sort(key=lambda x: x[0], reverse=True)
          beta_std.sort(key=lambda x: x[0], reverse=True)
          dev_std.sort(key=lambda x: x[0], reverse=True)
          dev_sub.sort(key=lambda x: x[0], reverse=True)
          ab_images.sort(key=lambda x: x[0], reverse=True)
          ab_sub.sort(key=lambda x: x[0], reverse=True)

          # Build hierarchical os_list
          os_list = []

          # 1. Add main stable images (top-level) - only latest
          if main_std:
              os_list.append(main_std[0][2])
              print(f"\n‚úì Added main stable: {main_std[0][2].get('name')}")

          # 2. Add beta images (top-level) - only latest
          if beta_std:
              os_list.append(beta_std[0][2])
              print(f"‚úì Added beta: {beta_std[0][2].get('name')}")

          # 3. Add Development Images folder (if any dev images exist)
          if dev_std or dev_sub:
              dev_subitems = [entry for _, _, entry in dev_std]

              # Add sub-branch folder if there are sub-branch images
              if dev_sub:
                  sub_folder = {
                      "name": "Other Development Builds",
                      "description": "Development builds from feature sub-branches",
                      "icon": "https://rasqberry.org/Artwork/RasQberry 2 Logo Cube 64x64.png",
                      "subitems": [entry for _, _, entry in dev_sub]
                  }
                  dev_subitems.append(sub_folder)

              dev_folder = {
                  "name": "RasQberry Development Images",
                  "description": "Development builds with cutting-edge features (unstable)",
                  "icon": "https://rasqberry.org/Artwork/RasQberry 2 Logo Cube 64x64.png",
                  "subitems": dev_subitems
              }
              os_list.append(dev_folder)
              print(f"‚úì Added Development folder with {len(dev_std)} main + {len(dev_sub)} sub-branch images")

          # 4. Add A/B Test Images folder (if any AB images exist)
          if ab_images or ab_sub:
              ab_subitems = [entry for _, _, entry in ab_images]

              # Add sub-branch folder if there are sub-branch A/B images
              if ab_sub:
                  sub_folder = {
                      "name": "Other A/B Builds",
                      "description": "A/B boot images from feature sub-branches",
                      "icon": "https://rasqberry.org/Artwork/RasQberry 2 Logo Cube 64x64.png",
                      "subitems": [entry for _, _, entry in ab_sub]
                  }
                  ab_subitems.append(sub_folder)

              ab_folder = {
                  "name": "RasQberry A/B Boot Images",
                  "description": "Images with A/B partition support for safer updates",
                  "icon": "https://rasqberry.org/Artwork/RasQberry 2 Logo Cube 64x64.png",
                  "subitems": ab_subitems
              }
              os_list.append(ab_folder)
              print(f"‚úì Added A/B folder with {len(ab_images)} main + {len(ab_sub)} sub-branch images")

          # Build final consolidated structure
          consolidated = {
              "imager": {
                  "latest_version": "1.8.5",
                  "url": "https://www.raspberrypi.com/software/"
              },
              "os_list": os_list
          }

          print(f"\n=== Built hierarchical structure with {len(os_list)} top-level entries ===")

          # Fetch official Raspberry Pi OS entry from their JSON
          raspios_entry = None
          try:
              with open('/tmp/rpi-official.json', 'r') as f:
                  rpi_data = json.load(f)

              # Navigate the structure to find Raspberry Pi OS (64-bit)
              # The official JSON has nested structure with os_list containing subitems
              def find_raspios_64bit(items):
                  for item in items:
                      name = item.get('name', '')
                      # Look for the recommended 64-bit desktop version
                      if 'Raspberry Pi OS' in name and '64-bit' in name and 'Lite' not in name and 'Full' not in name:
                          # Check if it has direct download info or subitems
                          if 'url' in item:
                              return item
                          if 'subitems' in item:
                              # Look in subitems for the main desktop version
                              for sub in item['subitems']:
                                  sub_name = sub.get('name', '')
                                  if 'Desktop' in sub_name or ('64-bit' in sub_name and 'Lite' not in sub_name):
                                      if 'url' in sub:
                                          return sub
                      # Recurse into subitems
                      if 'subitems' in item:
                          result = find_raspios_64bit(item['subitems'])
                          if result:
                              return result
                  return None

              raspios_entry = find_raspios_64bit(rpi_data.get('os_list', []))

              if raspios_entry:
                  # Clean up the entry to match our schema
                  clean_entry = {
                      "name": raspios_entry.get('name', 'Raspberry Pi OS (64-bit)'),
                      "description": raspios_entry.get('description', 'Official Raspberry Pi OS'),
                      "icon": raspios_entry.get('icon', 'https://downloads.raspberrypi.com/raspios_armhf/Raspberry_Pi_OS_(32-bit).png'),
                      "url": raspios_entry.get('url'),
                      "extract_size": raspios_entry.get('extract_size'),
                      "extract_sha256": raspios_entry.get('extract_sha256'),
                      "image_download_size": raspios_entry.get('image_download_size'),
                      "release_date": raspios_entry.get('release_date'),
                      "init_format": raspios_entry.get('init_format', 'systemd'),
                      "devices": raspios_entry.get('devices', ['pi5-64bit', 'pi4-64bit'])
                  }
                  # Remove None values
                  clean_entry = {k: v for k, v in clean_entry.items() if v is not None}
                  consolidated['os_list'].append(clean_entry)
                  print(f"\n‚úì Added official Raspberry Pi OS entry: {clean_entry.get('name')}")
                  print(f"  Release date: {clean_entry.get('release_date')}")
              else:
                  print("\n‚ö† Could not find Raspberry Pi OS (64-bit) in official JSON")
                  raise Exception("Fallback needed")

          except Exception as e:
              print(f"\n‚ö† Error fetching official Raspberry Pi OS: {e}")
              print("  Using fallback entry (may be outdated)")
              # Fallback to a known working entry
              consolidated['os_list'].append({
                  "name": "Raspberry Pi OS (64-bit)",
                  "description": "A port of Debian Bookworm with the Raspberry Pi Desktop (Recommended)",
                  "icon": "https://downloads.raspberrypi.com/raspios_armhf/Raspberry_Pi_OS_(32-bit).png",
                  "url": "https://downloads.raspberrypi.com/raspios_arm64/images/raspios_arm64-2024-10-28/2024-10-22-raspios-bookworm-arm64.img.xz",
                  "extract_size": 6102712320,
                  "extract_sha256": "88093218a66cf20e8669963902a949c4c23b73309c2fc3331d09fa6ee2134417",
                  "image_download_size": 1238664180,
                  "release_date": "2024-10-22",
                  "init_format": "systemd",
                  "devices": ["pi5-64bit", "pi4-64bit"]
              })

          # Note: Pi Imager has built-in "Use custom" option, no need to add our own

          # Report skipped entries (deleted releases)
          if skipped_entries:
              print("\n" + "="*60)
              print("‚ö† SKIPPED ENTRIES (releases no longer exist):")
              print("="*60)
              for entry in skipped_entries:
                  print(f"\n  Branch: {entry['branch']}")
                  print(f"  Name:   {entry['name']}")
                  print(f"  URL:    {entry['url']}")
                  print(f"  Reason: {entry['reason']}")
              print("\n" + "="*60)
              print(f"Total skipped: {len(skipped_entries)} entries")
              print("These branches have stale RQB-images.json files that should be updated.")
              print("="*60)

          # Write consolidated JSON to public folder (where website serves from)
          with open('public/RQB-images.json', 'w') as f:
              json.dump(consolidated, f, indent=2)

          print("\n=== Final RQB-images.json ===")
          print(json.dumps(consolidated, indent=2))

          # ================================================================
          # Generate RQB-releases.json for website /latest/ redirects
          # ================================================================
          from datetime import datetime, timezone

          def build_stream_entry(entries, stream_type):
              """Build a stream entry from the first (newest) entry in the list."""
              if not entries:
                  # No release available - return placeholder
                  messages = {
                      'stable': 'No stable release yet. Please use beta or dev.',
                      'beta': 'No beta release yet. Please use dev.',
                      'dev': 'No development release available.'
                  }
                  return {
                      'tag': None,
                      'name': None,
                      'message': messages.get(stream_type, 'No release available.'),
                      'release_url': 'https://github.com/${{ github.repository }}/releases'
                  }

              # Get the newest entry (already sorted by date)
              _, branch_name, entry = entries[0]

              # Extract tag from release_url or url
              tag = None
              release_url = entry.get('release_url', '')
              if '/releases/tag/' in release_url:
                  tag = release_url.split('/releases/tag/')[-1]
              elif '/releases/download/' in entry.get('url', ''):
                  # Extract from download URL: .../releases/download/TAG/filename
                  parts = entry.get('url', '').split('/releases/download/')
                  if len(parts) > 1:
                      tag = parts[1].split('/')[0]

              # Build the stream entry
              stream_entry = {
                  'tag': tag,
                  'name': entry.get('url', '').split('/')[-1].replace('.img.xz', '') if entry.get('url') else None,
                  'image_url': entry.get('url'),
                  'release_url': release_url or f"https://github.com/${{ github.repository }}/releases/tag/{tag}" if tag else f"https://github.com/${{ github.repository }}/releases",
                  'release_date': entry.get('release_date'),
                  'image_download_size': entry.get('image_download_size'),
              }

              # Add optional fields if present
              if entry.get('extract_size'):
                  stream_entry['extract_size'] = entry.get('extract_size')
              if entry.get('extract_sha256'):
                  stream_entry['extract_sha256'] = entry.get('extract_sha256')

              # Add highlights placeholder (can be enhanced later)
              stream_entry['highlights'] = ['extract highlights from GitHub release body']

              return stream_entry

          # Build RQB-releases.json
          releases_json = {
              'generated': datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%SZ'),
              'streams': {
                  'stable': build_stream_entry(main_std, 'stable'),
                  'beta': build_stream_entry(beta_std, 'beta'),
                  'dev': build_stream_entry(dev_std, 'dev'),
              }
          }

          # Write RQB-releases.json
          with open('public/RQB-releases.json', 'w') as f:
              json.dump(releases_json, f, indent=2)

          print("\n=== Final RQB-releases.json ===")
          print(json.dumps(releases_json, indent=2))

          # Write skipped entries to a separate file for reference
          if skipped_entries:
              with open('/tmp/skipped-releases.json', 'w') as f:
                  json.dump(skipped_entries, f, indent=2)
          PYTHON_SCRIPT

      - name: Commit consolidated JSON files to gh-pages
        id: commit
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          git add public/RQB-images.json public/RQB-releases.json

          # Check if there are changes
          if git diff --staged --quiet; then
            echo "No changes to JSON files"
            echo "changes=false" >> $GITHUB_OUTPUT
          else
            git commit -m "Consolidate RQB JSON files from all branches (triggered by ${{ github.event.inputs.trigger_source }})"

            # Retry push with pull --rebase to handle race conditions
            # (multiple workflows triggered by concurrent releases)
            for i in 1 2 3; do
              if git push origin gh-pages; then
                echo "‚úì RQB-images.json and RQB-releases.json committed to gh-pages"
                echo "changes=true" >> $GITHUB_OUTPUT
                exit 0
              else
                echo "Push failed (attempt $i), pulling and retrying..."
                git pull --rebase origin gh-pages
              fi
            done
            echo "Failed to push after 3 attempts"
            exit 1
          fi

      - name: Trigger Next.js deployment
        if: steps.commit.outputs.changes == 'true'
        continue-on-error: true  # Don't fail workflow if token lacks dispatch permission (e.g., release events from deleted branches)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Triggering Next.js deployment to update website..."
          gh workflow run "Deploy Next.js site to Pages" --ref gh-pages
          echo "‚úì Next.js deployment triggered"

      - name: Summary
        run: |
          echo "=== Consolidation Complete ==="
          echo ""
          echo "Trigger: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" = "schedule" ]; then
            echo "  (Scheduled 8-hour validation run)"
          elif [ "${{ github.event_name }}" = "release" ]; then
            echo "  (Release deletion detected)"
          fi
          echo ""
          echo "Validation: ${{ github.event.inputs.skip_validation == 'true' && 'SKIPPED' || 'ENABLED' }}"
          echo ""
          echo "Generated files on gh-pages:"
          echo ""
          echo "1. RQB-images.json (Pi Imager - hierarchical structure):"
          echo "   ‚îú‚îÄ‚îÄ RasQberry Two (64-bit)         - Main stable"
          echo "   ‚îú‚îÄ‚îÄ RasQberry Two Beta (64-bit)    - Beta release"
          echo "   ‚îú‚îÄ‚îÄ üìÅ RasQberry Development Images  - Dev builds (main + sub-branches)"
          echo "   ‚îú‚îÄ‚îÄ üìÅ RasQberry A/B Boot Images     - A/B images (main + sub-branches)"
          echo "   ‚îî‚îÄ‚îÄ Raspberry Pi OS (64-bit)       - Official Pi OS"
          echo ""
          echo "2. RQB-releases.json (Website /latest/ - stream structure):"
          echo "   ‚îú‚îÄ‚îÄ streams.stable  - Latest main branch release"
          echo "   ‚îú‚îÄ‚îÄ streams.beta    - Latest beta branch release"
          echo "   ‚îî‚îÄ‚îÄ streams.dev     - Latest dev branch release"
          echo ""
          # Report skipped entries if any
          if [ -f /tmp/skipped-releases.json ]; then
            echo "‚ö† WARNING: Some releases were skipped (deleted from GitHub):"
            cat /tmp/skipped-releases.json
            echo ""
          fi
          echo ""
          echo "Access URLs:"
          echo "  Pi Imager:  https://rasqberry.org/RQB-images.json"
          echo "  Website:    https://rasqberry.org/RQB-releases.json"
          echo "  Downloads:  https://rasqberry.org/latest/"
